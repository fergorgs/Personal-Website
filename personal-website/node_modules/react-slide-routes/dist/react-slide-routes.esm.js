import { jsx, css } from '@emotion/react';
import { useRef, useMemo, useEffect, Children, cloneElement } from 'react';
import t from 'prop-types';
import { useLocation, Routes } from 'react-router-dom';
import { TransitionGroup, CSSTransition } from 'react-transition-group';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

var _excluded = ["element"];

var _templateObject;

var getCss = function getCss(duration, timing, direction) {
  return css(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n  display: grid;\n\n  .item {\n    grid-area: 1 / 1 / 2 / 2;\n\n    &:not(:only-child) {\n      &.", "-enter-active, &.", "-exit-active {\n        transition: transform ", "ms ", ";\n      }\n    }\n  }\n\n  &.slide {\n    overflow: hidden;\n\n    // back\n    .back-enter {\n      transform: translateX(-100%);\n    }\n    .back-enter-active {\n      transform: translateX(0);\n    }\n    .back-exit {\n      transform: translateX(0);\n    }\n    .back-exit-active {\n      transform: translateX(100%);\n    }\n\n    // forward\n    .forward-enter {\n      transform: translateX(100%);\n    }\n    .forward-enter-active {\n      transform: translateX(0);\n    }\n    .forward-exit {\n      transform: translateX(0);\n    }\n    .forward-exit-active {\n      transform: translateX(-100%);\n    }\n  }\n\n  &.vertical-slide {\n    overflow: hidden;\n\n    // back\n    .back-enter {\n      transform: translateY(-100%);\n    }\n    .back-enter-active {\n      transform: translateY(0);\n    }\n    .back-exit {\n      transform: translateY(0);\n    }\n    .back-exit-active {\n      transform: translateY(100%);\n    }\n\n    // forward\n    .forward-enter {\n      transform: translateY(100%);\n    }\n    .forward-enter-active {\n      transform: translateY(0);\n    }\n    .forward-exit {\n      transform: translateY(0);\n    }\n    .forward-exit-active {\n      transform: translateY(-100%);\n    }\n  }\n\n  &.rotate {\n    perspective: 2000px;\n\n    .item {\n      backface-visibility: hidden;\n    }\n\n    // back\n    .back-enter {\n      transform: rotateY(-180deg);\n    }\n    .back-enter-active {\n      transform: rotateY(0);\n    }\n    .back-exit {\n      transform: rotateY(0);\n    }\n    .back-exit-active {\n      transform: rotateY(180deg);\n    }\n\n    // forward\n    .forward-enter {\n      transform: rotateY(180deg);\n    }\n    .forward-enter-active {\n      transform: rotateY(0);\n    }\n    .forward-exit {\n      transform: rotateY(0);\n    }\n    .forward-exit-active {\n      transform: rotateY(-180deg);\n    }\n  }\n"])), direction, direction, duration, timing);
};

var CACHE_KEY = '::slide::history::';

var SlideRoutes = function SlideRoutes(_ref) {
  var animation = _ref.animation,
      pathList = _ref.pathList,
      duration = _ref.duration,
      timing = _ref.timing,
      destroy = _ref.destroy,
      children = _ref.children;
  var location = useLocation();
  var pathname = location.pathname;
  var hasMount = useRef(false);
  var pathQueue = useRef();
  var SHOULD_UPDATE_CACHE = useRef(false);
  var prevPath = useRef();
  var direction = useRef('');

  if (!hasMount.current) {
    // mount
    hasMount.current = true;

    if (pathList.length > 0) {
      prevPath.current = pathname;
    } else {
      var cacheList = sessionStorage.getItem(CACHE_KEY);

      if (!cacheList) {
        prevPath.current = pathname;
        pathQueue.current = [pathname];
        SHOULD_UPDATE_CACHE.current = true;
      } else {
        pathQueue.current = JSON.parse(cacheList);
        prevPath.current = pathQueue.current[pathQueue.current.length - 1];
      }
    }
  } else {
    // update
    if (prevPath.current !== pathname) {
      if (pathList.length > 0) {
        var prevIndex = pathList.indexOf(prevPath.current);
        var nextIndex = pathList.indexOf(pathname);
        direction.current = prevIndex < nextIndex ? 'forward' : 'back';
      } else {
        var _nextIndex = pathQueue.current.lastIndexOf(pathname);

        if (_nextIndex === -1) {
          direction.current = 'forward';
          pathQueue.current.push(pathname);
        } else {
          direction.current = 'back';
          pathQueue.current.length = _nextIndex + 1;
        }

        SHOULD_UPDATE_CACHE.current = true;
      }

      prevPath.current = pathname;
    }
  }

  var cssProps = useMemo(function () {
    return destroy ? {
      timeout: duration
    } : {
      addEndListener: function addEndListener() {}
    };
  }, [destroy, duration]);
  useEffect(function () {
    if (SHOULD_UPDATE_CACHE.current) {
      SHOULD_UPDATE_CACHE.current = false;
      sessionStorage.setItem(CACHE_KEY, JSON.stringify(pathQueue.current));
    }
  });
  var routList = useMemo(function () {
    return Children.map(children, function (child) {
      if (!child) return child;

      var _child$props = child.props,
          element = _child$props.element,
          restProps = _objectWithoutPropertiesLoose(_child$props, _excluded);

      if (!element || element.props.replace === true) return child;
      var newElement = jsx("div", {
        className: "item"
      }, element);
      return _extends({}, child, {
        props: _extends({}, restProps, {
          element: newElement
        })
      });
    });
  }, [children]);
  return jsx(TransitionGroup, {
    className: "slide-routes " + animation,
    childFactory: function childFactory(child) {
      return /*#__PURE__*/cloneElement(child, {
        classNames: direction.current
      });
    },
    css: getCss(duration, timing, direction.current)
  }, jsx(CSSTransition, Object.assign({
    key: pathname
  }, cssProps), jsx(Routes, {
    location: location
  }, routList)));
};

SlideRoutes.defaultProps = {
  animation: 'slide',
  pathList: [],
  duration: 200,
  timing: 'ease',
  destroy: true
};
SlideRoutes.propTypes = {
  animation: t.oneOf(['slide', 'vertical-slide', 'rotate']),
  pathList: t.array,
  duration: t.number,
  timing: t.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']),
  destroy: t.bool,
  children: t.node
};

export { SlideRoutes as default };
